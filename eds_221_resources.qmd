---
title: "EDS221_Resource_Document"
format: html
editor: visual
Execute:
  warning:false
  message:false
---

# Quarto

see initial chunk for info on excluding warnings and messages

```{r}
#| fig-height: 5 
#| fig-width : 4
#these set the width of figures in output

```

## load packages/ hide in output

```{r output=FALSE}
library(here)
library(tidyverse)
library(janitor)
library(dplyr)

```

# Terminal

The terminal in R studio is the same as the terminal outside r studio.

Navigate to a folder that is version controlled and you can use git commands.

-   Git Add -A

-   Git commit -m "important message"

-   git push

-   git status

pwd

-   tells you where you are

cd ..

-   will take you back up one

ls

-   list all files

cd

-   sets working directory

# Pipe Operator

%\>% pipe operator or \|\>

-   basically means and then, allows you to write code in the order you think about it.

-   command shift m- shortcut

# Data Structures

## Data types

for more info on data types see lecture EDS 221 le

## atomic vector

when you combine data types in an atomic vector, will get converted to most flexible

1\) logical

2\) integer

3\) double

4)character (most flexible)

```{r}
turtle <- c(TRUE, 4.5, 8L)
turtle
class(turtle)
#converts all to numeric
#ask if it is numric
is.numeric(turtle)
#ask type
typeof(turtle)
```

```{r}

```

## List

a lot like a vector but different data types

good for outputs of models, so you can pull out individual items

```{r}
waffle <- list("dog", 21.5, "brown", 2L)
waffle
class(waffle)
```

named list

```{r}
tacos <- list(topping = c("onion", "cilantro","guacamole"), 
              filling = c("beans", "meat", "veggie"), price = c(6.75, 8.25, 9.50))
tacos
#indexing list elements by name
tacos$filling[2]
a <- c(1,2,3)
b <- c(3,4,5)
my_ttest <- t.test(a,b)
my_ttest
class(my_ttest)
#because it is in a list i can call certain elements
my_ttest$p.value #take the p value out
```

## Matrix

2 dimensional, only one data type

build a matrix from a vector

note that if you combine data types it will get converted to the most flexible

```{r}
#creating a matrix, default is to fill by ry
fish_sizea <- matrix(c(12, 14, 18, 20), ncol =2, nrow =2)

#example indexing
fish_sizea[1,1]
fish_sizea[2,1] # 2nd row 1st column
#empty matrix
data<-matrix(ncol=2,nrow=500)
```

### Leslie Matrix

A population of fish we're interested in has four life stages: eggs (E), fry (F), juvenile (J), breeding adult (A). You are told that annually:

\- Each breeding adult will produce, on average, 600 eggs

\- 5% of eggs will survive to become fry

\- 20% of fry will survive to become juveniles

\- 16% of juveniles will survive to become adults

\- Adult survival rate year to year is 90%

Recall the Leslie matrix from EDS 212. Matrix multiplication (using the dot product \`%\*%\` of the matrix with the populations at each life stage) yields the population structure at the following year.

Create the Leslie matrix:

Make the Leslie Matrix:

```{r}
fish_leslie <- matrix(c(0, 0, 0, 600, 0.05, 0, 0, 0, 0, 0.20, 0, 0, 0, 0, 0.16, 0.9), nrow = 4, ncol = 4, byrow = TRUE)
```

matrix shows the chances of surviving to each life stage

we created in eds 212, see eds212_day-4-part1- slides for review on writing equations as matrices

fish_leslie

The initial population structure is given by:

```{r}
# Initial population structure (Roe, Fry, Juvenile, Adult): 

fish_year0 <- c(5000, 8000, 600, 400)
```

Add line-by-line comments wheres prompted in the code below, explaining what each is doing. Make sure that you are talking with your neighbors about what is really being created at each step.

```{r}
# Model projections

# using the matrix and the dot product with the pop at t-1

# create a vector sequence from 0 to 8 at intervals of one

time_yr <- seq(from = 0, to = 8, by = 1)

# creating an empty matrix

proj_year <- matrix(ncol = length(fish_year0), nrow = length(time_yr))

# fills the first row of the empty matrix with the initial population 

proj_year[1, ] <- fish_year0

# populates the matrix with the dot product of fish leslie and year - 1, giving us the population for each year, we are starting at i in 2 so it doesn't overwrite initial population. taking the dot product of survival matrix with the previous years values (in the row above) 

for (i in 2:length(time_yr)) {

  proj_year[i,] <- fish_leslie %*% proj_year[i-1,]

}

#why is this not tidy? population single variable spread over four columns, 

# The rest is wrangling & visualization (run to check it out):

colnames(proj_year) <- c("eggs", "fry", "juvenile", "adult")

#first one compresses time into one columns, and then collapse everything besides time-year columns, put them into a life stage column, tidy format!

proj_df <- data.frame(time_yr, proj_year) %>% 

 #pivot longer, first argument what columns do you want to collapse, -time_year(everything except for time year)

  #pivot longer increaes rows and decreases columns

   pivot_longer(cols = -time_yr, names_to = "lifestage", values_to = "stage_population")

ggplot(data = proj_df, aes(x = time_yr, y = stage_population)) +

  geom_line(aes(color = lifestage)) +

  scale_y_log10()
```

Test different combinations of survival / reproduction and starting population structures to see what happens!

## data frames (make them!)

most commonly used, stores the data you have read in. Under the hood is a list of vectors, each having the same length.

2D and can have multiple data types

```{r}
topping <- c("onion", "cilantro", "guacamole")
filling <- c("beans", "meat", "veggies")
price <- c(6.75, 8.25, 9.5)

df_ex_1 <- data.frame(topping, filling, price)
class(df_ex_1)

df_ex_2 <- data.frame(topping = c("sour cream", "salsa", "cheese"), filling = c("chicken", "cheese", "cabbage"), price = c(12.50, 13.75, 15.00))

#another way to make a dataframe using tribble
#allows you to write it in the same organization as you would see it in the dataframe
df_ex_3 <- tribble(
  ~topping, ~filling, ~price,
  "avocado", "steak", 13.25,
  "raddish", "fish", 10.40,
  "salsa", "veggies", 9.75
)
class(df_ex_3)
#class additionally associated with data.frame
df_ex_3$price
df_ex_3$price[3]


```

## building data frame using tribble

# Indexing

## Vector

```{r}
dog_food <-c(teddy = "purina", khora = "alpo", waffle = "fancy feast")
#added names to vector, teddy, khora and waffle w/ values in quotation marks. 
# can call by position
dog_food[2]
#or name
dog_food["khora"]
```

```{r}
cars <- c("blue", "orange", "white")
cars[1]
i <- seq(1:2)
cars[i]

#replace white with yellow
cars[3] <- "yellow"
cars
```

## Matrix

```{r}
#creating a matrix, filling by column instread of row
fish_size <- matrix(c(12, 14, 18, 20), ncol =2, nrow =2, byrow =FALSE)
class(fish_size)
typeof(fish_size)
#example indexing
fish_size[1,1]
fish_size[2,1] # 2nd row 1st column
#look at second row but keep all columns
fish_size[2,]
#keep all rows only 1st column
fish_size[,1]
```

## data frame

```{r}
aquatic_dataseta <- read_csv(here("data", "AS00601.csv")) %>% clean_names()
#Store the 5th value in column “WEIGHT” as mc_wt_5.
mc_wt_5 <- aquatic_dataseta$weight[5]
# Store the 8th - 20th value in the “LENGTH1” column as
mc_length_8_20<- aquatic_dataseta$length1[8:20]
#same thing different method
mc_length_8_20 <- aquatic_dataseta$length1[seq(from = 8, to = 20, by = 1)]
# Store everything in column SAMPLEDATE as a vector called
mc_dates <- aquatic_dataseta$sampledate

```

# If Statements, for loops and string detect

## If Statements

{ used to group statements

```{r}
# think of it as, if is the function, curly brackets contain what will happen
burrito <- 2
if (burrito < 5) {
  print("I love potatoes")
} 
# nothing will print
burritos <- 0.7
if (burritos > 2) {
  print("I love burritos")
}
```

## If else statements

Create a vector stored as `max_airtemp_c` with a value of 24.1. Write an `if else` statement that will print "Temperature too high" if `max_airtemp_c` is greater than 27, or "Temperature OK" if temperature is less than or equal to 27.

```{r}
max_airtemp_c <- 26
if( max_airtemp_c > 27){
  print("Temperature too high")
} else if (max_airtemp_c <= 26){
  print("Temperature OK")
}
```

## string detect

```{r}
# condition w/ words
# does this pattern show up anywhere in this element
my_ships <- c("millenium falcon", "X-wing", "Tie-fighter", "Death Star")
str_detect(my_ships, pattern = "millenium")

#use an if statement w. string detect

#plugging str_detect into an if statement
coho <- "salmonids"
if(str_detect(coho, pattern = "sal")){
  print("The very best fish")
}


```

## Combine string detect with if else

Store the base price of a burrito as base_burrito with a value of 6.50. Store main_ingredent with a starting string of "veggie." Write a statement that will return the price of a burrito based on what a user specifies as "main_ingredient" (either "veggie", "chicken" or "steak") given the following:

A veggie burrito is the cost of a base burrito

A chicken burrito costs 3.00 more than a base burrito

A steak burrito costs 3.25 more than a base burrito

```{r}
base_burrito <- 6.5
main_ingredient <- "steak"
if(str_detect(main_ingredient, "veggie")){
  print(base_burrito)
} else if (str_detect(main_ingredient, "chicken")){
  print(base_burrito + 3.00)
} else if (str_detect(main_ingredient, "steak")){
  print(base_burrito +3.25)
}
```

this will return the same results using the == sign instead of str_detect

```{r}

base_burrito <- 6.5
main_ingredient <- "chicken"
if(main_ingredient == "veggie"){
  print(base_burrito)
} else if (main_ingredient == "chicken"){
  print(base_burrito + 3.00)
} else 
  print(base_burrito + 3.25)

```

# For Loops

Create a new vector called fish that contains the values 8, 10, 12, 23 representing counts of different fish types in a fish tank (goldfish, tetras, guppies, and mollies, respectively). Write a for loop that iterates through fish, and returns what proportion of total fish in the tank are that species. Assume that these counts represent all fish in the tank.

```{r}
fish <- c(8, 10, 12, 23)
for(i in seq_along(fish)){
  val = fish[i]/sum(fish)
  print(val)
}
```

## 

There is an existing vector in R called month.name that contains all month names (just Try running month.name in the Console to check it out). Write a for loop that iterates over all months in month.name and prints "January is month 1," "February is month 2", etc.

```{r}
values <- seq_along(month.name)
for( i in seq_along(month.name)){
  val = paste(month.name[i], "is month", values[i])
  print(val)
}

```

Write a for loop that returns your total time for any two consecutive quarter miles, given times in minutes

```{r}
#adding each one to the next one
quarter_splits <- c(1.0, 1.1, 1.2, 1.1, 1.4, 1.5, 1.6, 1.4)

for(i in seq_along(quarter_splits)){
  print(quarter_splits[i]+ quarter_splits[i +1])
  
}
```

## Applying functions across a dataframe

also known as syntactic sugar for for loops

use select when you want to select columns

### filter

```{r}
#read in the data and clean names
toolik_biochem <- read_csv(here("data","2011_Kling_Akchem.csv"), na = ".") |> clean_names()
#create a subset of the data that contains only observations from the “Toolik Inlet” site, and that only contains the variables (columns) for pH, dissolved organic carbon (DOC), and total dissolved nitrogen (TDN) 
# use filter to pull within a column

inlet_biochem <- toolik_biochem |>
  filter(site == "Toolik Inlet") |> #use select to choose which columns
  select(p_h, doc_u_m, tdn_u_m)


```

### dplyr:: across, group_by and summarize

```{r}
#find the mean of inlet_biochem using summarize, na.rm = TRUE tells it to ignore NA values
#w/o across you must specify each column
summarize(inlet_biochem, mean(p_h, na.rm = TRUE), mean(doc_u_m, na.rm = TRUE), mean(tdn_u_m, na.rm = TRUE))

#w/across, any spot that is numeric
inlet_biochem |> summarize(across(where(is.numeric), mean, na.rm = TRUE))
```

### apply

1 = apply function over rows, 2 = apply function over columns

```{r}
apply(X =inlet_biochem, MARGIN = 2, FUN = mean, na.rm = TRUE)
```

### purr

```{r}
map(.x = inlet_biochem,.f = mean, na.rm = TRUE)
```

# Working With Files & Tidy Data

## Exploring your data

```{r}
#tells you column names
names(mtcars)
# an overview
skimr::skim(mtcars)
#dimensions, rows, columns
dim(mtcars)

#ask data type of columns
is.numeric(mtcars$mpg)
#getmorespecific data type
typeof(mtcars$cyl)
```

```{r}

```

## Here

Here Package: much better option than using working directory

## Importing and Exporting Files

add file paths starting from here location

```{r}
# import and fix the names
blood_lead <- read_csv(here("data","stl_blood_lead.csv" )) %>% clean_names() #automatically makes names lowercase, see ?to_any_case w/ janitor package loaded to see case options
#make a new column
blood_lead_pov <- mutate(blood_lead, 
                         new_col = poverty_tot/total_pop *100)
#Graph a plot
lead_poverty_plot <- ggplot(data = blood_lead_pov, aes(x = pct_elevated, y = new_col)) + geom_point(color = "pink") +labs(x = "percent of population in poverty", y = "Percent of population with elevated blood levels")
lead_poverty_plot
#save the file in the project
#dpi specifies resolution, med 200-300
ggsave(plot = lead_poverty_plot, here("figs","lead_plot.png"), width = 4, height = 4, )
```

### Importing data with abnormal NA values

```{r}
#this dataset has . in place of NA 
Kling <- read_csv(here("data", "2011_Kling_Akchem.csv"), na = ".")
```

## mutating and filtering data

Dataset from: <https://portal.edirepository.org/nis/mapbrowse?packageid=knb-lter-and.4027.14>use filter when you want to pull a certain set of values from column

```{r}
#import dataset and clean names 
aquatic_dataset <- read_csv(here("data", "AS00601.csv")) %>% clean_names()

#filter returns rows matching conditions
#Filter for cutthroat 
cutthroat_dataset <- filter(aquatic_dataset, species == "ONCL")
# mutate creates modifies and deletes columns
#add a new column w/ k factor 
cuttthroat_k <- mutate(cutthroat_dataset, k_factor = (100 * weight) / ( (0.1 *length1) ^3))
#graph
ggplot(cutthroat_dataset, aes(x = unittype)) +geom_bar(color = "green", fill = "yellow") + labs( Title = "Unit Types for Cuthroat", x= "Unit Type", y ="Count")
```

## Summarize and group by 

```{r}
#group by year and average k factor
k_year <- group_by(cuttthroat_k,year) |> summarize(mean_k = mean(k_factor, na.rm =TRUE)) |> filter(year >= 2008)
#another plot
ggplot(data = k_year, aes(x = year, y = mean_k))+geom_point() +scale_x_continuous(breaks=c(2008:2018), labels=c(2008:2018),limits=c(2008,2018))
```

<https://portal.edirepository.org/nis/mapbrowse?packageid=knb-lter-arc.10341.5>

## 

# Functions

asks for a users name and age and returns, "I'm blank and I am age years old!"

```{r}
age_name <- function(age,name){
  paste("My name is", name, "and I am", age, "years old")
}
age_name(29, "Adelaide")
```

#converts animal age to human age

```{r}
convert_animal_age <- function(animal, human_age){
  if(animal == "dog"){
    print(human_age * 7)
  } else if (animal == "goat"){
    print(human_age * 4.7)
  } else print("not a dog or a goat")
  
}
#tell me the human age of this goat
convert_animal_age("goat",89)
# gives the else value 
convert_animal_age("chicken", 22)
```

### make a tribble and filter

```{r}
dog_choice <- tribble(
  ~dog_name, ~food,
  "khora", "everything",
  "Teddy", "Salmon",
  "waffle", "pancakes",
  "Banjo", "chicken")

dog_menu <- function(name){
  my_sub <-filter(dog_choice, dog_name == name)
print(my_sub)
}
dog_menu("khora")
#outputs a data frame

```

Or pull from the dataframe for use in the output

```{r}
dog_choice2 <- tribble(
  ~dog_name, ~food,
  "khora", "everything",
  "Teddy", "Salmon",
  "waffle", "pancakes",
  "Banjo", "chicken",
  "gigi", "tennis balls"
  )

dog_menu <- function(name){
  my_sub <-filter(dog_choice2, dog_name == name)
print(paste("My name is", my_sub$dog_name, "and I like to eat", my_sub$food ))
}
dog_menu("gigi")
```

### Functions meet four loops

makes a function to calculate mean over columns

```{r}
mean_over_columns<- function(df){
  for(i in seq_along(df)){
    col_mean <- mean(df[[i]], na.rm = TRUE)
  colum_name <- colnames(df[i])
  print(paste("The mean value of", colum_name, "is",
              col_mean))
  }
}
mean_over_columns(mtcars)
```

## Testing functions

<https://testthat.r-lib.org/>

## adding warnings

# Sourcing Scripts
